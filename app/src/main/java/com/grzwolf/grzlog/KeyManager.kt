package com.grzwolf.grzlog

import android.app.Activity
import android.content.Context
import android.security.KeyPairGeneratorSpec
import android.util.Base64
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.math.BigInteger
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.SecureRandom
import java.security.interfaces.RSAPublicKey
import java.util.Calendar
import javax.crypto.Cipher
import javax.crypto.CipherInputStream
import javax.crypto.CipherOutputStream
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec
import javax.security.auth.x500.X500Principal

//
// App data shall be stored encrypted in a simple text file
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// - asymmetric encryption/decryption with public/private keys from KeyStore
//   is safe, but it too slow for larger texts
//   --> do not use this way for huge data amounts
//   --> only use this way for small texts, like a password
// - symmetric encryption/decryption is much faster (10x), but needs a password,
//   which needs to be stored in the app's context in a safe way
//   --> a random password is once generated by the app
//   --> this password is encrypted asymmetrically with the app's KeyStore public key
//   --> this encrypted password is stored in the app's preferences
//   --> if the password is needed to symmetrically encrypt/decrypt app data, is is read from
//       the app's preferences and decrypted asymmetrically with the app's KeyStore private key
//

//
// ------------ asymmetric data encryption/decryption with public and private keys ----------------
//
class KeyManager(private val context: Context, keyStoreAlias: String, private val appName: String) {
    private val alias: String = keyStoreAlias
    private val keyStoreName = "AndroidKeyStore"
    private val keyStore = KeyStore.getInstance(keyStoreName)
    private val tag = "$appName KeyManager"

    init {
        keyStore.load(null)
        createAppKeys()
    }

    private fun createAppKeys() {
        try {
            // only create a new key pair if needed
            if (!keyStore.containsAlias(alias)) {
                // the key pair is valid for 100 years :)
                val start: Calendar = Calendar.getInstance()
                val end: Calendar = Calendar.getInstance()
                end.add(Calendar.YEAR, 100)
                val spec = KeyPairGeneratorSpec.Builder(context)
                    .setAlias(alias)
                    .setSubject(X500Principal("CN=$appName, O=$appName Authority"))
                    .setSerialNumber(BigInteger.ONE)
                    .setStartDate(start.getTime())
                    .setEndDate(end.getTime())
                    .build()
                val generator = KeyPairGenerator.getInstance("RSA", keyStoreName)
                generator.initialize(spec)
                generator.generateKeyPair()
            }
        } catch (e: java.lang.Exception) {
            (context as Activity).runOnUiThread {
                centeredToast(context, context.getString(R.string.no_encryption_available), 3000)
            }
        }
    }

    // checks whether a given String is encrypted with the app's private key
    fun isEncryptedWithPub(textToCheck: String): Boolean {
        try {
            val privateKeyEntry = keyStore.getEntry(alias, null) as KeyStore.PrivateKeyEntry
            val privateKey = privateKeyEntry.privateKey

            val output = Cipher.getInstance("RSA/ECB/PKCS1Padding")
            output.init(Cipher.DECRYPT_MODE, privateKey)

            val cipherText: String = textToCheck
            val cipherInputStream = CipherInputStream(
                ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output
            )
            val values = ArrayList<Byte>()
            var nextByte: Int
            while ((cipherInputStream.read().also { nextByte = it }) != -1) {
                values.add(nextByte.toByte())
            }

            val bytes = ByteArray(values.size)
            for (i in bytes.indices) {
                bytes[i] = values[i]
            }

            val finalText = String(bytes, 0, bytes.size, charset("UTF-8"))

            // if logic ends here, we could be sure about the assessment
            return true

        } catch (e: java.lang.Exception) {
            return false
        }
    }

    // encrypt the given String with the app's public key
    fun encryptPub(initialText: String): String {
        try {
            val privateKeyEntry = keyStore.getEntry(alias, null) as KeyStore.PrivateKeyEntry
            val publicKey = privateKeyEntry.certificate.publicKey as RSAPublicKey

            val input = Cipher.getInstance("RSA/ECB/PKCS1Padding", "AndroidOpenSSL")
            input.init(Cipher.ENCRYPT_MODE, publicKey)

            val outputStream = ByteArrayOutputStream()
            val cipherOutputStream = CipherOutputStream(
                outputStream, input
            )
            cipherOutputStream.write(initialText.toByteArray(charset("UTF-8")))
            cipherOutputStream.close()

            val vals = outputStream.toByteArray()
            val crypted = Base64.encodeToString(vals, Base64.DEFAULT)
            return crypted

        } catch (e: java.lang.Exception) {
            (context as Activity).runOnUiThread {
                centeredToast(context, context.getString(R.string.encryption_failed) + " Pub", 3000)
            }
            return initialText
        }
    }

    // decrypt the given String with the app's private key
    fun decryptPub(cryptText: String): String {
        try {
            val privateKeyEntry = keyStore.getEntry(alias, null) as KeyStore.PrivateKeyEntry
            val privateKey = privateKeyEntry.privateKey

            val output = Cipher.getInstance("RSA/ECB/PKCS1Padding")
            output.init(Cipher.DECRYPT_MODE, privateKey)

            val cipherText: String = cryptText
            val cipherInputStream = CipherInputStream(
                ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output
            )
            val values = ArrayList<Byte>()
            var nextByte: Int
            while ((cipherInputStream.read().also { nextByte = it }) != -1) {
                values.add(nextByte.toByte())
            }

            val bytes = ByteArray(values.size)
            for (i in bytes.indices) {
                bytes[i] = values[i]
            }

            val finalText = String(bytes, 0, bytes.size, charset("UTF-8"))
            return finalText

        } catch (e: java.lang.Exception) {
            (context as Activity).runOnUiThread {
                centeredToast(context, context.getString(R.string.decryption_failed) + " Prv", 3000)
            }
            return cryptText
        }
    }

    //
    // -------- symmetric data encryption/decryption with asymmetric password protection ----------
    //
    // symmetric data encryption/decryption is 10x faster as asymmetric encryption/decryption
    //

    // generate a pwd
    // kudos: https://developermemos.com/posts/generating-password-kotlin
    fun generateRandomPassword(length: Int): String {
        val charset = ('A'..'Z') +
                ('a'..'z') + ('0'..'9') +
                listOf('!', '@', '#', '$', '%', '^', '&', '*', '(', ')')
        val secureRandom = SecureRandom()
        return (1..length)
            .map { charset[secureRandom.nextInt(charset.size)] }
            .joinToString("")
    }

    // encrypt a given password with the app's public key --> this is safe to store in app prefs
    fun encryptPwdPub(clearPwd: String): String {
        val encryptedPwd = encryptPub(clearPwd)
        return encryptedPwd
    }

    // decrypt a given password with the app's private key --> after retrieving it from app prefs
    fun decryptPwdPrv(encryptedPwd: String): String {
        val clearPwd = decryptPub(encryptedPwd)
        return clearPwd
    }

    // kudos: https://medium.com/@appdevinsights/implementation-of-aes-encryption-in-android-dca250525b4
    // Galois/Counter Mode (GCM) Mode
    fun encryptGCM(plainText: String, key: String): String {
        try {
            val keyArr = key.toByteArray()
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val secretKey: SecretKey = SecretKeySpec(keyArr, "AES")
            cipher.init(Cipher.ENCRYPT_MODE, secretKey)
            val iv = cipher.iv
            val encryptedBytes = cipher.doFinal(plainText.toByteArray())
            return Base64.encodeToString(
                encryptedBytes,
                Base64.DEFAULT
            ) + ":" + Base64.encodeToString(iv, Base64.DEFAULT)
        } catch (e: java.lang.Exception) {
            return ""
        }
    }
    fun decryptGCM(encryptedText: String, key: String): String {
        try {
            val keyArr = key.toByteArray()
            val parts = encryptedText.split(":")
            val encryptedData = Base64.decode(parts[0], Base64.DEFAULT)
            val iv = Base64.decode(parts[1], Base64.DEFAULT)
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val secretKey: SecretKey = SecretKeySpec(keyArr, "AES")
            val gcmParameterSpec = GCMParameterSpec(128, iv)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec)
            val decryptedBytes = cipher.doFinal(encryptedData)
            return String(decryptedBytes)
        } catch (e: java.lang.Exception) {
            (context as Activity).runOnUiThread {
                centeredToast(context, context.getString(R.string.decryption_failed) + " GCM", 3000)
            }
            return ""
        }
    }
}


